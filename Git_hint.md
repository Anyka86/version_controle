# Подсказка по GIT


# Создание репозитория:
## создает новый репозиторий Git
```sh
git init
```
## добавляет изменение из рабочего каталога в раздел проиндексированных файлов
```sh
git add 'nameFile'
```
## создать коммит и указать его описание
```sh
git commit -m "message"
```
## просмотреть сделанные коммиты и информацию о них
```sh
git log
```
## выводит именно короткий хэш
```sh
git log --oneline
```
## перейти в нужную версию проекта или коммит по его хешу, который отражается в выводе команды git log
```sh
git checkout <название ветки>
```
## переход к другой ветке

```sh
git commit -m “message”
```
## создание коммита.
```sh
git branch
````
## посмотреть список веток в репозитории
```sh
git branch <название ветки> 
```
## создать новую ветку
```sh
git checkout <название ветки> 
```
## переход к другой ветке
```sh
git branch -d <название ветки>
```
## удалить ветку

```sh
git show <название идентификатор>
```
## Просмотр заданного коммита

```sh
git diff
```
## Просмотр изменений до коммита

```sh
git diff --staged
```
### Для просмотра подготовленных изменений необходимо добавить флаг --staged.

```sh
git diff somefile.js
```
### Также можно указать имя файла как параметр и просмотреть изменения, внесённые только в этот файл.

```sh
git rm dirname/somefile.js
```
## Удалять файлы из текущего рабочего дерева можно с помощью параметра rm. При этом файлы удаляются и из индекса.

```sh
git rm dirname/*.html
```
### Можно также использовать маски файлов (например *.js) для удаления всех файлов, соответствующих критерию.

```sh
git mv dir1/somefile.js dir2
```
## Переименование файлов
#### Переименовать файл или папку можно параметром mv. Для него указывается источник source и назначение destination. Источник — реально существующий файл или папка, а назначение — существующая папка.
##### При выполнении команды файл или папка, указанные как источник, будут перемещены в папку назначения. Индекс будет обновлён соответственно, но изменения нужно записать.

```sh
git checkout somefile.js
```
## Отмена подготовленных и неподготовленных изменений
```sh
git reset HEAD somefile.js
```
### Восстановить подготовленный файл рабочего дерева можно параметром reset. Потребуется указать путь к файлу, чтобы убрать его из области подготовленных файлов. При этом не будет производиться откат никаких изменений или модификаций — однако файл перейдёт в категорию не подготовленных к коммиту.
```sh
git reset HEAD
```
### Если нужно выполнить это действие для всех подготовленных файлов, путь к ним указывать не надо.
```sh
git commit --amend -m "Updated message for the previous commit"
```
 ## Изменение последнего коммита

 ```sh
 git revert HEAD
 ```
 ## Откат последнего коммита
```sh 
 git revert 
 git reset.
 ```
 ### Команда git revert отменяет изменения, записанные только одним коммитом. Она не откатывает проект к более раннему состоянию, удаляя все последующие коммиты, как это делает команда git reset.

 ```sh 
 git revert
 ```
 ### гораздо более удобный и безопасный способ отмены изменений.

 ```sh 
 git revert 1af17e
 ```
 ## Откат заданного коммита

  ```sh
  git merge existing_branch_name
  ```
  ## Слияние двух веток

  ```sh
  git merge --no-ff existing_branch_name
  ```
  ### Указанная команда объединит заданную ветку с основной и произведёт коммит слияния. Это необходимо для фиксации всех слияний в вашем репозитории


```sh
git log --graph --oneline --decorate
```
## Отображение журнала фиксации в виде графика для текущей или всех веток
 ```sh
 git log --all --graph --oneline --decorate
```
### Для просмотра истории коммитов по всем веткам используется флаг --all.

```sh
git merge --abort
```
## Прекращение слияния при конфликте
```sh
git reset
```
### Также при конфликте слияния можно использовать параметр reset, чтобы восстановить конфликтующие файлы до стабильного состояния

```sh
git remote add awesomeapp https://github.com/someurl..
```
## Добавление удалённого репозитория
### Добавить удалённый репозиторий можно параметром remote add, указав shortname и url требуемого репозитория.

```sh
git remote -v
```
## Просмотр удалённых URL-адресов
### Просматривать удалённые URL-адреса можно параметром remote с флагом -v. Этот параметр отображает удалённые подключения к другим репозиториям.
### Такая команда открывает доступ к интерфейсу управления удалёнными записями, которые хранятся в файле .git/config репозитория.

```sh
git remote show origin
```
## Получение дополнительных сведений об удалённом репозитории

### Эта команда отображает список веток, связанных с удалённым репозиторием, а также рабочих станций, подключённых для получения и отправки файлов.

```sh
git push origin main
```
## Отправка изменений в удалённый репозиторий
### Эта команда передаёт локальные изменения в центральный репозиторий, где с ними могут ознакомиться другие участники проекта.

```sh
git pull
```
## Получение изменений из удалённого репозитория
### Для загрузки изменений из удалённого репозитория используется параметр pull. Он скачивает копию текущей ветки с указанного удалённого репозитория и объединяет её с локальной копией.
```sh
git pull --verbose
```
### Также можно просмотреть подробные сведения о загруженных файлах с помощью флага --verbose.

```sh
git merge origin
```
## Слияние удалённого репозитория с локальным
### Слияние удалённого репозитория с локальным выполняется параметром merge с указанием имени удалённого репозитория.

```sh
git push -u origin new_branch
```
## Отправка новой ветки в удалённый репозиторий
### Передать новую ветку в удалённый репозиторий можно параметром push с флагом -u, указав имя репозитория и имя ветки.

```sh
git push --delete origin existing_branch
```
## Удаление удалённой ветки
### Чтобы избавиться от удалённой ветки, используйте параметр push с флагом --delete, указав имя удалённого репозитория и имя ветки.

```sh
git rebase branch_name
```
##  Использование перебазирования
#### Для доступа к этой функции используйте параметр rebase с указанием имени ветки. Перебазирование — это процесс объединения или перемещения последовательности коммитов на новый родительский снимок.
##### Эта команда изменит основу ветки с одного коммита на другой, как если бы вы начали ветку с другого коммита. В Git это достигается за счёт создания новых коммитов и применения их к указанному базовому коммиту. Необходимо понимать, что, хотя ветка и выглядит такой же, она состоит из совершенно новых коммитов.